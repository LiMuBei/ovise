#ifndef DOTSCENEXMLREADER_H_
#define DOTSCENEXMLREADER_H_

// Xerces includes
#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/dom/DOM.hpp>
#include <xercesc/sax/HandlerBase.hpp>
#include <xercesc/util/XMLString.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include <string>
// Include for Ogre Logging
#include "Ogre.h"

#include "dotScene.h"

#ifdef XERCES_NEW_IOSTREAMS
#include <iostream>
#else
#include <iostream.h>
#endif


XERCES_CPP_NAMESPACE_USE
using namespace std;

/**
 * Struct defining a light source.
 * A node can be a light source, in which case the needed information can be found here.
 */
struct XMLLight
{
	/// Name of the light source
	string mName;
	/// Type of the light source, e.g. point
	string mType;
	/// Diffuse colour [0]=r, [1]=g, [2]=b
	double mColourDiffuse[3];
	/// Specular colour [0]=r, [1]=g, [2]=b
	double mColourSpecular[3];
	/// Attenuation range
	double mLightAttenuationRange;
	/// Attenuation constant portion
	double mLightAttenuationConst;
	/// Attenuation linear portion
	double mLightAttenuationLinear;
	/// Attenuation quadratic portion
	double mLightAttenuationQuad;
};

/**
 * Struct defining a camera.
 * A node can be a camera, in which case the needed information can be found here.
 */
struct XMLCamera
{
	/// Camera name
	string mName;
	/// Angle of field of view
	double mFOV;
	/// Projection type, e.g. perspective
	string mProjectionType;
	/// Near clipping plane distance
	double mClippingNearPlaneDist;
	/// Far clipping plane distance
	double mClippingFarPlaneDist;
};

/**
 * Struct that stores the information about a scene node from the dotScene xml-file.
 * Used in the Scene-class to create a blueprint of the scene.
 */
struct XMLSceneNode
{
	/**
	 * What type of node do we have.
	 */
	enum XMLNodeType {
		ENTITY = 1,
		LIGHT = 2,
		CAMERA = 3
	} mType;
	
	/// Name of the node, must be unique in Ogre
	string mName;
	
	/**
	 * Position of the node in the scene (relative to parent?).
	 * mPosition[0] = x, mPosition[1] = y, mPosition[2] = z
	 */
	double mPosition[3];
	/**
	 * Orientation of the node in the scene (relative to parent?).
	 * mQuaternion[0] = x, mQuaternion[1] = y, mQuaternion[2] = z, mQuaternion[3] = w
	 */
	double mQuaternion[4];
	/**
	 * Scale of the node (relative to parent?).
	 * mScale[0] = x, mScale[1] = y, mScale[2] = z
	 */
	double mScale[3];
	
	/// Name of the entity, usually equal with the node name
	string mEntityName;
	/// Name of the mesh file referenced by this node, usually "mEntityName.mesh"
	string mEntityMeshFile;
	
	/// If node is a light source, info can be found here
	XMLLight mLight;
	
	/// If node is a camera, info can be found here
	XMLCamera mCamera;
	
	/** 
	 * Parent node.
	 * If NULL, then the node doesn't have a parent.
	 */
	XMLSceneNode *parent;
	/**
	 * List of child nodes.
	 * If size is 0, there are no child nodes.
	 */ 
	vector<XMLSceneNode*> children;
	
	/// Cleanup
	void deleteChildren();
};

/**
 * Class representing a scene generated in Blender to be imported into Ogre.
 * The Blender sceneexporter creates a XML-file containing all nodes and their
 * structure. The Scene-class is the internal representation of that XML-file
 * and is used by the factory class as a blueprint to recreate that scene
 * using the Ogre scene graph. The scene can thus be created multiple times
 * and be attached at whatever scene node chosen.
 */
class Scene
{
public:
	/// Constructor
	Scene(string name);
	
	/// Get name of scene
	string getName();
	
	/// Get number of nodes
	int getNumberOfNodes();
	
	/**
	 * Get node by name.
	 * @param name Name of the node you're looking for
	 * @return Pointer to first node with given name, NULL if no node with given name exists.
	 */
	XMLSceneNode* getNodeByName(string name);
	/**
	 * Get node by index.
	 * @param index Index of node
	 * @return Pointer to searched node, NULL if index is out of bounds.
	 */
	XMLSceneNode* getNode(int index);
	
	/**
	 * Add new node to the list.
	 * @param node Pointer to node to add
	 * @return true on success, false on error
	 */
	bool addNode(XMLSceneNode *node);
	
	/// Destructor
	~Scene();
	
private:
	/// Name of the scene.
	string mName;
	/**
	 * List of nodes the scene contains.
	 * This list contains all nodes (usually meshes) a scene contains. Each node
	 * knows its own position and orientation as well as its mesh. The nodes can be
	 * organized in a hierarchical structure with each node possibly having a parent and
	 * a list of child nodes. This structure will then be recreated using the Ogre scene graph.
	 */
	vector<XMLSceneNode*> mNodes;
};


/**
 * Class for validating and parsing XML-based scene description files generated by
 * the Blender dotScene exporter.
 * The class utilizes the Xerces XML-Parser to validate the given XML-file against the given
 * schema (.xsd). After that the class stores a "blueprint" of the given scene which can then
 * be used to create the scene in Ogre.
 */
class DotSceneXmlReader
{
public:
	/// Constructor that wants a XSD schema file. 
	DotSceneXmlReader(string URLofDotSceneXSD, bool DbgMode = false);
	
	/**
	 * Parse a dotScene xml-file into the internal structure.
	 * 
	 */
	bool importDotScene(dotSceneObjects::dotScene *pScene);
	
	/**
	 * Validates and parses the given XML-scenefile.
	 * @return true on success, false on error
	 */
	bool parseDotSceneXML(string URLofXML);
	/**
	 * Processes the parsed XML-file to create an instance of the Scene-class.
	 * @param newScene Pointer to a valid instance of Scene
	 * @return true on success, false on error
	 */
	bool processDotScene(Scene *newScene);
	
	/// Destructor.
	~DotSceneXmlReader();
	
private:
	/// Stores the location of the used schema file.
	string mURLofDotSceneXSD;
	/// Stores the location of the XML-scenefile.
	string mURLofDotSceneXML;
	/// Switch for debug mode. Intended for development usage.
	bool mDebugMode;
	/// The DOM parser
	XercesDOMParser *mParser;
	/// Error handler for ther parser
	ErrorHandler *mErrHandler;
	
	/**
	 * Internal function to recursively parse an XML file.
	 * The function is given a starting <node>-tag. It reads all child tags and processes them.
	 * If a nested <node>-tag is found it steps down recursively. In every recusrion step a new XMLSceneNode
	 * is created and filled with the needed information.
	 * @param node The <node>-tag to process
	 * @param parent the parent XMLSceneNode to this node
	 */
	XMLSceneNode* parseNode(DOMNode *node, XMLSceneNode *parent);
	
	/**
	 * Internal function to recursively parse an XML file.
	 * The function is given a starting <node>-tag. It reads all child tags and processes them.
	 * If a nested <node>-tag is found it steps down recursively. In every recusrion step a new XMLSceneNode
	 * is created and filled with the needed information.
	 * @param node The <node>-tag to process
	 * @param parent the parent dotSceneNode to this node
	 */
	dotSceneObjects::dotSceneObject* parseNodeItem(DOMNode *node);
	
	// Used XML-Tags and attributes
	XMLCh* TAG_scene;
	XMLCh* ATTR_formatVersion;
	XMLCh* TAG_nodes;
	XMLCh* TAG_node;
	XMLCh* TAG_environment;
	XMLCh* ATTR_name;
	XMLCh* TAG_position;
	XMLCh *ATTR_x, *ATTR_y, *ATTR_z;
	XMLCh* TAG_quaternion;
	XMLCh* ATTR_w;
	XMLCh* TAG_scale;
	XMLCh* TAG_entity;
	XMLCh* ATTR_meshFile;
	XMLCh* ATTR_static;
	XMLCh* ATTR_visible;
	XMLCh* ATTR_castShadows;
	XMLCh* ATTR_renderingDistance;
	XMLCh* TAG_light;
	XMLCh* TAG_lightRange;
	XMLCh* TAG_normal;
	XMLCh* ATTR_r;
	XMLCh* ATTR_g;
	XMLCh* ATTR_b;
	XMLCh* TAG_colourSpecular;
	XMLCh* TAG_colourDiffuse;
	XMLCh* TAG_colourAmbient;
	XMLCh* TAG_colourBackground;
	XMLCh* TAG_fog;
	XMLCh* TAG_lightAttenuation;
	XMLCh* ATTR_range;
	XMLCh* ATTR_constant;
	XMLCh* ATTR_linear;
	XMLCh* ATTR_quadratic;
	XMLCh* TAG_camera;
	XMLCh* ATTR_fov;
	XMLCh* ATTR_projectionType;
	XMLCh* TAG_clipping;
	XMLCh* ATTR_nearPlaneDist;
	XMLCh* ATTR_farPlaneDist;
	XMLCh* TAG_externals;
	XMLCh* TAG_item;
	XMLCh* ATTR_type;
	XMLCh* TAG_file;
};

#endif /*DOTSCENEXMLREADER_H_*/
